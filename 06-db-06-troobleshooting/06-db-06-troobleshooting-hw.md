Задача 1
---
Перед выполнением задания ознакомьтесь с документацией по администрированию MongoDB.

Пользователь (разработчик) написал в канал поддержки, что у него уже 3 минуты происходит CRUD-операция в MongoDB и её нужно прервать.

Вы как инженер поддержки решили произвести эту операцию:

напишите список операций, которые вы будете производить для остановки запроса пользователя;

* Определить идентификатор операции, которую нужно прервать. Это можно сделать с помощью команды db.currentOp(), которая покажет все текущие операции в MongoDB
* Используя идентификатор операции, можно прервать её с помощью команды db.killOp(идентификатор операции)

предложите вариант решения проблемы с долгими (зависающими) запросами в MongoDB.

* Создайть индексы для ускорения поиска и сортировки документов. Индексы позволяют MongoDB эффективно выбирать документы, соответствующие критериям запроса.
* Рассмотрить возможность использования шардинга для распределения данных по нескольким серверам MongoDB. Это может помочь улучшить производительность при работе с большими объемами данных.
* Настроить мониторинг производительности MongoDB с помощью инструментов мониторинга, таких как MongoDB Cloud Manager или MMS. Это поможет быстро обнаруживать проблемы и решать их.
***

Задача 2
---

Перед выполнением задания познакомьтесь с документацией по Redis latency troobleshooting.

Вы запустили инстанс Redis для использования совместно с сервисом, который использует механизм TTL. Причём отношение количества записанных key-value-значений к количеству истёкших значений есть величина постоянная и увеличивается пропорционально количеству реплик сервиса.

При масштабировании сервиса до N реплик вы увидели, что:

сначала происходит рост отношения записанных значений к истекшим,

Redis блокирует операции записи.

Как вы думаете, в чём может быть проблема?

**Ответ**

Redis - это хранилище данных в памяти, которое использует ключ-значение как основную структуру данных. Оно поддерживает автоматическое удаление данных с помощью механизма TTL. Когда TTL истекает, ключ автоматически уничтожается.

Возможно, проблема связана с тем, что Redis должен постоянно проверять и удалять истекшие ключи, что может заблокировать операции записи. При масштабирование сервиса до N реплик, увеличивается нагрузка на Redis и вызвает конкуренцию за ресурсы.

Redis проверяет небольшое количество случайных ключей из набора истекающих ключей на каждом цикле событий. Если эти ключи истекли, Redis удалит их. Если более чем 25% проверенных ключей истекли, Redis повторит этот процесс снова до тех пор, пока процент истекших ключей не станет меньше 25%.

Если  есть большое количество ключей, которые истекают в одно и то же время, Redis может потратить много времени на удаление этих ключей, что может привести к блокировке записи.

***

Задача 3
---
Вы подняли базу данных MySQL для использования в гис-системе. При росте количества записей в таблицах базы пользователи начали жаловаться на ошибки вида:

InterfaceError: (InterfaceError) 2013: Lost connection to MySQL server during query u'SELECT..... '

Как вы думаете, почему это начало происходить и как локализовать проблему?

Какие пути решения этой проблемы вы можете предложить?

**Ответ**

Ошибка “InterfaceError: 2013: Lost connection to MySQL server during query” обычно возникает при выполнении длительных или сложных запросов к MySQL, которые занимают больше времени, чем установленное значение тайм-аута.

причиной этой ошибки могут быть:

* Проблемы с сетевым подключением
* Длительные запросы
* Большие объемы данных

Возможные решения проблемы:

* Увеличить тайм-аут подключения
* Увеличить максимальный размер пакета
* Добавить ресурсов на машине БД

***

Задача 4
---

Вы решили перевести гис-систему из задачи 3 на PostgreSQL, так как прочитали в документации, что эта СУБД работает с большим объёмом данных лучше, чем MySQL.

После запуска пользователи начали жаловаться, что СУБД время от времени становится недоступной. В dmesg вы видите, что:

postmaster invoked oom-killer

Как вы думаете, что происходит?

* Сообщение postmaster invoked oom-killer указывает на то, что процесс PostgreSQL был завершен системой из-за нехватки оперативной памяти.

Как бы вы решили эту проблему?

* Увеличение оперативной памяти
* Оптимизация использования памяти PostgreSQL:

shared_buffers: Этот параметр определяет количество памяти, выделенной PostgreSQL для кэширования данных. Если уменьшить это значение, PostgreSQL будет использовать меньше памяти, но это может привести к снижению производительности из-за увеличения операций ввода-вывода.

work_mem: Этот параметр определяет количество памяти, выделенной для внутренних операций сортировки и хэширования. Уменьшение этого значения может помочь снизить общее потребление памяти, но это также может привести к использованию дискового пространства для этих операций, что снизит производительность.

maintenance_work_mem: Этот параметр определяет максимальное количество памяти, которое может быть использовано операциями обслуживания, такими как VACUUM и CREATE INDEX. Уменьшение этого значения может помочь снизить потребление памяти во время этих операций.

effective_cache_size: Этот параметр используется планировщиком запросов PostgreSQL для оценки стоимости операций ввода-вывода. Увеличение этого значения может помочь улучшить производительность запросов за счет более эффективного использования кэша

* Использование SWAP
* Распределение нагрузки на несколько серверов




